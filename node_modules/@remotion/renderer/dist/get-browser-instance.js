"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPageAndCleanupFn = void 0;
const browser_1 = require("./browser");
const logger_1 = require("./logger");
const open_browser_1 = require("./open-browser");
const getPageAndCleanupFn = async ({ passedInInstance, browserExecutable, chromiumOptions, forceDeviceScaleFactor, indent, logLevel, onBrowserDownload, }) => {
    if (passedInInstance) {
        const page = await passedInInstance.newPage(() => null, logLevel, indent);
        return {
            page,
            cleanupPage: () => {
                // Close puppeteer page and don't wait for it to finish.
                // Keep browser open.
                page.close().catch((err) => {
                    if (!err.message.includes('Target closed')) {
                        logger_1.Log.error({ indent, logLevel }, 'Was not able to close puppeteer page', err);
                    }
                });
                return Promise.resolve();
            },
        };
    }
    const browserInstance = await (0, open_browser_1.internalOpenBrowser)({
        browser: browser_1.DEFAULT_BROWSER,
        browserExecutable,
        chromiumOptions,
        forceDeviceScaleFactor,
        indent,
        viewport: null,
        logLevel,
        onBrowserDownload,
    });
    const browserPage = await browserInstance.newPage(() => null, logLevel, indent);
    return {
        page: browserPage,
        cleanupPage: () => {
            // Close whole browser that was just created and don't wait for it to finish.
            browserInstance.close(true, logLevel, indent).catch((err) => {
                if (!err.message.includes('Target closed')) {
                    logger_1.Log.error({ indent, logLevel }, 'Was not able to close puppeteer page', err);
                }
            });
            return Promise.resolve();
        },
    };
};
exports.getPageAndCleanupFn = getPageAndCleanupFn;
